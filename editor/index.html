<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RPG DREAM EDITOR</title>
<style>
:root{
 --bg:#0b0718;--panel:#16102a;--stroke:#3a2b7a;--primary:#7b5cff;
 --text:#efeaff;--white:#ffffff
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);
 font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif}
#topbar{display:flex;align-items:center;gap:8px;padding:10px;
 background:var(--panel);border-bottom:1px solid var(--stroke)}
#topbar .spacer{flex:1}
button{background:var(--primary);border:none;border-radius:12px;
 color:#fff;padding:8px 12px;font-size:13px}
button.secondary{background:transparent;border:1px solid var(--primary)}
button.active{outline:2px solid #fff}
canvas{display:block;touch-action:none}
#toolbar{display:flex;gap:8px;padding:8px;background:#120b22;
 border-bottom:1px solid var(--stroke)}
.tool-modal{position:fixed;right:12px;top:120px;background:var(--panel);
 border:1px solid var(--stroke);border-radius:14px;padding:12px;
 min-width:260px;z-index:10}
.tool-modal.hidden{display:none}
.tool-modal h4{margin:0 0 8px 0}
.tool-modal .close{float:right;background:transparent;color:#fff}
#phaseLabel{
 position:fixed;left:50%;bottom:6px;transform:translateX(-50%);
 color:#7bffcc;font-weight:700;letter-spacing:.08em;
 text-shadow:0 0 6px rgba(123,255,204,.6)
}
#toast{
 position:fixed;left:50%;bottom:40px;transform:translateX(-50%);
 background:#1b1340;border:1px solid var(--stroke);
 border-radius:12px;padding:8px 12px;font-size:12px;display:none
}
</style>
</head>
<body>

<div id="topbar">
 <strong>Editor</strong>
 <div class="spacer"></div>
 <button id="saveBtn">Save</button>
</div>

<div id="toolbar">
 <button id="toolPaint">Paint</button>
 <button id="toolErase" class="secondary">Erase</button>
 <button id="toolPan" class="secondary">Pan</button>
 <button id="toolRegion" class="secondary">Region</button>
 <button id="toolObject" class="secondary">Object</button>
</div>

<canvas id="canvas"></canvas>

<div id="regionModal" class="tool-modal hidden">
 <button class="close" onclick="closeModals()">✕</button>
 <h4>Regions</h4>
 <div style="font-size:12px;opacity:.8">Active Region</div>
 <select id="regionSelect" style="color:white"></select>
</div>

<div id="objectModal" class="tool-modal hidden">
 <button class="close" onclick="closeModals()">✕</button>
 <h4>Objects</h4>
 <div style="font-size:12px;opacity:.8">Type</div>
 <select id="objectType" style="color:white">
  <option value="crate">Crate</option>
  <option value="barrel">Barrel</option>
  <option value="tree">Tree</option>
 </select>
 <div style="margin-top:8px;font-size:12px;opacity:.8">Rotation</div>
 <select id="objectRot" style="color:white">
  <option value="0">0°</option>
  <option value="90">90°</option>
  <option value="180">180°</option>
  <option value="270">270°</option>
 </select>
 <div style="margin-top:10px">
  <button id="deleteObjBtn" class="secondary">Delete Selected</button>
 </div>
</div>

<div id="phaseLabel">PHASE 14E.1c</div>
<div id="toast">Saved ✔</div>

<script>
// ---- Boot & rehydration ----
const active = JSON.parse(localStorage.getItem("rpgdream_active_project")||"null");
if(!active){ location.href="../manager/index.html"; }

const VIEW_MODE = active.view === "angular" ? "angular" : "topdown";

// ---- Canvas ----
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
let dpr=window.devicePixelRatio||1;
let scale=1, offsetX=0, offsetY=0;
const MIN_ZOOM=.5, MAX_ZOOM=2.5;

const tileSize=Number(active.tile)||32;
const GRID_PRESETS={small:20, medium:40, large:80};
const GRID_MAX=GRID_PRESETS[active.grid]||40;

// ---- Data ----
const terrain=new Map(Object.entries(active?.data?.map?.terrain||{}));
const regions=active?.data?.map?.regions||{};
const objects=active?.data?.map?.objects||[];
let currentTool="paint", selectedObject=null, activeRegionId=null;

// ---- Helpers ----
function gridToScreen(x,y){
 if(VIEW_MODE==="angular") return {x:(x-y)*(tileSize/2),y:(x+y)*(tileSize/4)};
 return {x:x*tileSize,y:y*tileSize};
}
function screenToGrid(px,py){
 if(VIEW_MODE==="angular"){
  const gx=Math.round((px/(tileSize/2)+py/(tileSize/4))/2);
  const gy=Math.round((py/(tileSize/4)-px/(tileSize/2))/2);
  return {x:gx,y:gy};
 }
 return {x:Math.floor(px/tileSize),y:Math.floor(py/tileSize)};
}

// ---- Render ----
function resize(){
 canvas.width=innerWidth*dpr;
 canvas.height=(innerHeight-120)*dpr;
 canvas.style.width=innerWidth+"px";
 canvas.style.height=(innerHeight-120)+"px";
 ctx.setTransform(dpr,0,0,dpr,0,0);
 draw();
}
window.addEventListener("resize",resize);

function draw(){
 ctx.save();
 ctx.clearRect(0,0,canvas.width,canvas.height);
 ctx.translate(offsetX,offsetY);
 ctx.scale(scale,scale);

 // grid
 ctx.strokeStyle="rgba(255,255,255,.15)";
 for(let x=-GRID_MAX;x<=GRID_MAX;x++){
  for(let y=-GRID_MAX;y<=GRID_MAX;y++){
   const p=gridToScreen(x,y);
   if(VIEW_MODE==="angular"){
    ctx.beginPath();
    ctx.moveTo(p.x, p.y-tileSize/4);
    ctx.lineTo(p.x+tileSize/2, p.y);
    ctx.lineTo(p.x, p.y+tileSize/4);
    ctx.lineTo(p.x-tileSize/2, p.y);
    ctx.closePath(); ctx.stroke();
   } else ctx.strokeRect(p.x,p.y,tileSize,tileSize);
  }
 }

 // terrain
 ctx.fillStyle="#7b5cff";
 for(const k of terrain.keys()){
  const [x,y]=k.split(",").map(Number);
  const p=gridToScreen(x,y);
  if(VIEW_MODE==="angular"){
   ctx.beginPath();
   ctx.moveTo(p.x, p.y-tileSize/4);
   ctx.lineTo(p.x+tileSize/2, p.y);
   ctx.lineTo(p.x, p.y+tileSize/4);
   ctx.lineTo(p.x-tileSize/2, p.y);
   ctx.closePath(); ctx.fill();
  } else ctx.fillRect(p.x,p.y,tileSize,tileSize);
 }

 // objects
 objects.forEach(o=>{
  const p=gridToScreen(o.x,o.y);
  ctx.save();
  ctx.translate(p.x+tileSize/2,p.y+tileSize/2);
  ctx.rotate((o.rot||0)*Math.PI/180);
  ctx.fillStyle=o===selectedObject?"#ffd36a":"#ccc";
  ctx.fillRect(-tileSize/2,-tileSize/2,tileSize,tileSize);
  ctx.restore();
 });

 ctx.restore();
}

// ---- Interaction ----
let isPanning=false, panStart={x:0,y:0}, camStart={x:0,y:0};

canvas.addEventListener("pointerdown",e=>{
 const rect=canvas.getBoundingClientRect();
 const px=(e.clientX-rect.left-offsetX)/scale;
 const py=(e.clientY-rect.top-offsetY)/scale;

 if(currentTool==="pan"){
  isPanning=true;
  panStart={x:e.clientX,y:e.clientY};
  camStart={x:offsetX,y:offsetY};
  return;
 }

 const g=screenToGrid(px,py);
 if(g.x<-GRID_MAX||g.x>GRID_MAX||g.y<-GRID_MAX||g.y>GRID_MAX) return;
 const key=g.x+","+g.y;

 if(currentTool==="paint") terrain.set(key,true);
 if(currentTool==="erase") terrain.delete(key);

 if(currentTool==="object"){
  selectedObject=null;
  for(const o of objects){
   if(o.x===g.x && o.y===g.y){ selectedObject=o; break; }
  }
  if(!selectedObject){
   const o={id:Date.now(),type:objectType.value,x:g.x,y:g.y,rot:Number(objectRot.value)};
   objects.push(o); selectedObject=o;
  }
 }

 draw();
});

canvas.addEventListener("pointermove",e=>{
 if(currentTool==="pan" && isPanning){
  offsetX=camStart.x+(e.clientX-panStart.x);
  offsetY=camStart.y+(e.clientY-panStart.y);
  draw();
 }
});
canvas.addEventListener("pointerup",()=>isPanning=false);
canvas.addEventListener("pointerleave",()=>isPanning=false);

// Zoom
canvas.addEventListener("wheel",e=>{
 e.preventDefault();
 const delta=e.deltaY>0?.9:1.1;
 const rect=canvas.getBoundingClientRect();
 const cx=e.clientX, cy=e.clientY;
 const newScale=Math.min(MAX_ZOOM,Math.max(MIN_ZOOM,scale*delta));
 const x=(cx-rect.left-offsetX)/scale;
 const y=(cy-rect.top-offsetY)/scale;
 offsetX-=x*(newScale-scale);
 offsetY-=y*(newScale-scale);
 scale=newScale;
 draw();
},{passive:false});

// ---- Toolbar wiring ----
function closeModals(){
 document.querySelectorAll(".tool-modal").forEach(m=>m.classList.add("hidden"));
}
function setTool(t){
 currentTool=t;
 document.querySelectorAll("#toolbar button").forEach(b=>b.classList.remove("active"));
 closeModals();
 if(t==="paint") toolPaint.classList.add("active");
 if(t==="erase") toolErase.classList.add("active");
 if(t==="pan") toolPan.classList.add("active");
 if(t==="region"){ toolRegion.classList.add("active"); regionModal.classList.remove("hidden"); }
 if(t==="object"){ toolObject.classList.add("active"); objectModal.classList.remove("hidden"); }
}
toolPaint.onclick=()=>setTool("paint");
toolErase.onclick=()=>setTool("erase");
toolPan.onclick=()=>setTool("pan");
toolRegion.onclick=()=>setTool("region");
toolObject.onclick=()=>setTool("object");
setTool("paint");

deleteObjBtn.onclick=()=>{
 if(!selectedObject) return;
 const i=objects.indexOf(selectedObject);
 if(i>=0) objects.splice(i,1);
 selectedObject=null;
 draw();
};

// ---- Save ----
saveBtn.onclick=()=>{
 const projects=JSON.parse(localStorage.getItem("rpgdream_projects")||"[]");
 const payload={map:{terrain:Object.fromEntries(terrain),regions,objects}};
 const idx=projects.findIndex(p=>p.id===active.id);
 if(idx>=0) projects[idx].data=payload;
 else projects.push({...active,data:payload});
 localStorage.setItem("rpgdream_projects",JSON.stringify(projects));
 toast.style.display="block";
 setTimeout(()=>toast.style.display="none",900);
};

resize(); draw();
</script>
</body>
</html>
