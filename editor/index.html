<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RPG DREAM EDITOR</title>
<style>
:root{
  --bg:#0b0718;--panel:#16102a;--stroke:#3a2b7a;--primary:#7b5cff;
  --text:#efeaff;--white:#ffffff
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);
  font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif}
#topbar{display:flex;align-items:center;gap:8px;padding:10px;
  background:var(--panel);border-bottom:1px solid var(--stroke)}
#topbar .spacer{flex:1}
button{background:var(--primary);border:none;border-radius:12px;
  color:#fff;padding:8px 12px;font-size:13px}
button.secondary{background:transparent;border:1px solid var(--primary)}
button.active{outline:2px solid #fff}
select{
  background:#120b22;color:var(--white);
  border:1px solid var(--stroke);border-radius:10px;padding:6px
}
canvas{display:block;touch-action:none}
#toolbar{display:flex;gap:8px;padding:8px;background:#120b22;
  border-bottom:1px solid var(--stroke)}
.tool-modal{position:fixed;right:12px;top:120px;background:var(--panel);
  border:1px solid var(--stroke);border-radius:14px;padding:12px;
  min-width:260px;z-index:10}
.tool-modal.hidden{display:none}
.tool-modal h4{margin:0 0 8px 0}
.tool-modal .close{float:right;background:transparent;color:#fff}
#toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);
  background:#1b1340;border:1px solid var(--stroke);
  border-radius:12px;padding:8px 12px;font-size:12px;display:none}
#phaseLabel{
  position:fixed;left:50%;bottom:6px;transform:translateX(-50%);
  color:#7bffcc;font-weight:700;letter-spacing:.08em;
  text-shadow:0 0 6px rgba(123,255,204,.6)
}
</style>
</head>
<body>
<div id="topbar">
  <strong>Editor</strong>
  <div class="spacer"></div>
  <button id="saveBtn">Save</button>
</div>

<div id="toolbar">
  <button id="toolPaint">Paint</button>
  <button id="toolErase" class="secondary">Erase</button>
  <button id="toolPan" class="secondary">Pan</button>
  <button id="toolRegion" class="secondary">Region</button>
  <button id="toolObject" class="secondary">Object</button>
</div>

<canvas id="canvas"></canvas>

<div id="objectModal" class="tool-modal hidden">
  <button class="close" onclick="closeModals()">✕</button>
  <h4>Objects</h4>
  <div style="font-size:12px;opacity:.8">Type</div>
  <select id="objectType">
    <option value="crate">Crate</option>
    <option value="barrel">Barrel</option>
    <option value="tree">Tree</option>
  </select>
  <div style="margin-top:8px;font-size:12px;opacity:.8">Rotation</div>
  <select id="objectRot">
    <option value="0">0°</option>
    <option value="90">90°</option>
    <option value="180">180°</option>
    <option value="270">270°</option>
  </select>
  <div style="margin-top:10px;display:flex;gap:8px">
    <button id="deleteObjBtn" class="secondary">Delete Selected</button>
  </div>
</div>

<div id="phaseLabel">PHASE 14E</div>
<div id="toast">Saved</div>

<script>
const active = JSON.parse(localStorage.getItem("rpgdream_active_project")||"null");
if(!active){ location.href="../manager/index.html"; }

const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");
let dpr=window.devicePixelRatio||1;
let scale=1, offsetX=0, offsetY=0;
const MIN_ZOOM=.5, MAX_ZOOM=2.5;

const tileSize=Number(active.tile)||32;
const viewMode=active.view||"topdown";
const GRID_PRESETS={small:20, medium:40, large:80};
const GRID_MAX=GRID_PRESETS[active.grid]||40;

const terrain=new Map();
const regions={};
const objects=[];
let selectedObject=null;

let currentTool="paint";
let isPanning=false, panStart={x:0,y:0}, camStart={x:0,y:0};

function resize(){
  canvas.width=innerWidth*dpr;
  canvas.height=(innerHeight-120)*dpr;
  canvas.style.width=innerWidth+"px";
  canvas.style.height=(innerHeight-120)+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}
window.addEventListener("resize",resize);

function gridToScreen(x,y){
  return { x:x*tileSize, y:y*tileSize };
}
function screenToGrid(px,py){
  return {x:Math.floor(px/tileSize),y:Math.floor(py/tileSize)};
}

function drawObject(o){
  const p=gridToScreen(o.x,o.y);
  ctx.save();
  ctx.translate(p.x+tileSize/2,p.y+tileSize/2);
  ctx.rotate(o.rot*Math.PI/180);
  ctx.fillStyle=o===selectedObject?"#ffd36a":"#cccccc";
  ctx.fillRect(-tileSize/2,-tileSize/2,tileSize,tileSize);
  ctx.restore();
}

function draw(){
  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.translate(offsetX,offsetY);
  ctx.scale(scale,scale);

  ctx.strokeStyle="rgba(255,255,255,.15)";
  for(let x=-GRID_MAX;x<=GRID_MAX;x++)for(let y=-GRID_MAX;y<=GRID_MAX;y++){
    const p=gridToScreen(x,y);
    ctx.strokeRect(p.x,p.y,tileSize,tileSize);
  }

  ctx.fillStyle="#7b5cff";
  terrain.forEach((_,k)=>{
    const [x,y]=k.split(",").map(Number);
    const p=gridToScreen(x,y);
    ctx.fillRect(p.x,p.y,tileSize,tileSize);
  });

  objects.forEach(drawObject);
  ctx.restore();
}

canvas.addEventListener("pointerdown",e=>{
  const rect=canvas.getBoundingClientRect();
  const px=(e.clientX-rect.left-offsetX)/scale;
  const py=(e.clientY-rect.top-offsetY)/scale;

  if(currentTool==="pan"){
    isPanning=true; panStart={x:e.clientX,y:e.clientY};
    camStart={x:offsetX,y:offsetY}; return;
  }

  const g=screenToGrid(px,py);
  if(currentTool==="paint") terrain.set(g.x+","+g.y,true);
  if(currentTool==="erase") terrain.delete(g.x+","+g.y);

  if(currentTool==="object"){
    selectedObject=null;
    for(const o of objects){
      if(o.x===g.x && o.y===g.y){ selectedObject=o; break; }
    }
    if(!selectedObject){
      const o={id:Date.now(),type:objectType.value,x:g.x,y:g.y,rot:Number(objectRot.value)};
      objects.push(o);
      selectedObject=o;
    }
  }
  draw();
});

canvas.addEventListener("pointermove",e=>{
  if(currentTool==="pan" && isPanning){
    offsetX=camStart.x+(e.clientX-panStart.x);
    offsetY=camStart.y+(e.clientY-panStart.y);
    draw();
  }
});
canvas.addEventListener("pointerup",()=>isPanning=false);

canvas.addEventListener("wheel",e=>{
  e.preventDefault();
  const delta=e.deltaY>0?.9:1.1;
  zoomAt(e.clientX,e.clientY,delta);
},{passive:false});

function zoomAt(cx,cy,f){
  const newScale=Math.min(MAX_ZOOM,Math.max(MIN_ZOOM,scale*f));
  const rect=canvas.getBoundingClientRect();
  const x=(cx-rect.left-offsetX)/scale;
  const y=(cy-rect.top-offsetY)/scale;
  offsetX-=x*(newScale-scale);
  offsetY-=y*(newScale-scale);
  scale=newScale; draw();
}

function closeModals(){ document.querySelectorAll('.tool-modal').forEach(m=>m.classList.add('hidden')); }
function setTool(t){
  currentTool=t;
  document.querySelectorAll('#toolbar button').forEach(b=>b.classList.remove('active'));
  closeModals();
  if(t==="paint") toolPaint.classList.add('active');
  if(t==="erase") toolErase.classList.add('active');
  if(t==="pan") toolPan.classList.add('active');
  if(t==="object"){ toolObject.classList.add('active'); objectModal.classList.remove('hidden'); }
}
toolPaint.onclick=()=>setTool("paint");
toolErase.onclick=()=>setTool("erase");
toolPan.onclick=()=>setTool("pan");
toolObject.onclick=()=>setTool("object");

deleteObjBtn.onclick=()=>{
  if(!selectedObject) return;
  const i=objects.indexOf(selectedObject);
  if(i>=0) objects.splice(i,1);
  selectedObject=null; draw();
};

function serialize(){
  const projects=JSON.parse(localStorage.getItem("rpgdream_projects")||"[]");
  const payload={ map:{ terrain:Object.fromEntries(terrain), objects } };
  const idx=projects.findIndex(p=>p.id===active.id);
  if(idx>=0) projects[idx].data=payload;
  localStorage.setItem("rpgdream_projects",JSON.stringify(projects));
}
saveBtn.onclick=()=>{ serialize(); toast(); };
function toast(){ toastEl.style.display="block"; setTimeout(()=>toastEl.style.display="none",900); }
const toastEl=document.getElementById('toast');

resize(); draw();
</script>
</body>
</html>
